// Provides a set of functions for estimating the beats of a piece of music from a set of 'taps'.
//
// The 'taps' would typically (but not exclusively) be generated by a person tapping on a keyboard
// in time to the music, but the functions can be used to estimate and linearize the beats from
// other beat detection algorithms.
//
// The beats are estimated by clustering the 'taps' into a set of optimal beats using the ckmeans.1d.dp
// algorithm, followed by optional quantization to adjust the estimated beats to a match a fixed BPM and
// (optionally) extrapolation to fill in missing beats.
package taps2beats

import (
	"encoding/json"
	"fmt"
	"math"
	"sort"
	"time"

	"github.com/twystd/taps2beats/taps2beats/ckmeans"
	"github.com/twystd/taps2beats/taps2beats/regression"
)

// Contains the estimated BPM, offset of the first beat and the beats estimated from a set of 'taps'.
type Beats struct {
	BPM    uint          `json:"BPM"`
	Offset time.Duration `json:"offset"`
	Beats  []Beat        `json:"beats"`
}

// Contains the estimated time of a single beat, the mean and variance of the 'taps' that were
// used to estimate the beat and a list of the 'taps' that were assigned to this beat.
type Beat struct {
	beat     int             `json:"-"`
	At       time.Duration   `json:"at"`
	Mean     time.Duration   `json:"mean"`
	Variance time.Duration   `json:"variance"`
	Taps     []time.Duration `json:"taps"`
}

// Used for marshaling and unmarshaling time as untyped seconds when marshaling and unmarshaling
// to/from JSON.
type instant time.Duration

// Marshals an instant as the equivalent seconds value, rounded to the nearest millisecond.
func (t instant) MarshalText() ([]byte, error) {
	s := fmt.Sprintf("%.3f", time.Duration(t).Seconds())

	return []byte(s), nil
}

// Unmarshals an instant as seconds from a float64 value.
func (t *instant) UnmarshalText(s []byte) error {
	if t != nil {
		var v float64

		_, err := fmt.Sscanf(string(s), "%f", &v)
		if err != nil {
			return err
		}

		*t = instant(v * float64(time.Second))
	}

	return nil
}

const (
	MaxBPM         int = 200 // Maximum BPM that will be used when quantizing and interpolating beats
	MinSubdivision int = 8   // Minimum subdivision (eighths) that will be used when quantizing and interpolating beats
)

// Clusters the provided 'taps' into an optimal set of beats and estimates the average BPM and the offset of the
// first beats (on the assumption that the BPM is fixed).
//
// The supplied list of 'taps' may contain multiple loops, with each loop being a separate row in the list.
//
// The forgetting factor is used to discount earlier loops in favour of later loops, on the grounds that later 'taps'
// will probably be more accurate. A forgetting factor of 0.0 assumes all taps are equally accurate, while a value of
// 0.1 discounts each loop by 10% over the subsequent loop. A forgetting factor of -0.1 discounts each subsequent loop
// by 10% over the preceding loop.
func Taps2Beats(taps [][]time.Duration, forgetting float64) Beats {
	data := []float64{}
	for _, row := range taps {
		for _, t := range row {
			data = append(data, t.Seconds())
		}
	}

	clusters := ckmeans.CKMeans1dDp(data, weights(taps, forgetting))

	beats := make([]Beat, len(clusters))
	for i, cluster := range clusters {
		beats[i] = makeBeat(cluster.Center, cluster)
	}

	BPM, offset := bpm(beats)

	sort.SliceStable(beats, func(i, j int) bool { return beats[i].At < beats[j].At })

	return Beats{
		BPM:    BPM,
		Offset: offset,
		Beats:  beats,
	}
}

// Adjusts the times of the beats by performing a least squares reqression to fit the estimated beats to
// a straight line (on the assumption that the BPM is reasonably constant).
func (beats *Beats) Quantize() error {
	switch {
	case beats == nil:
		return nil

	case len(beats.Beats) < 1:
		beats.BPM = 0
		beats.Offset = 0 * time.Millisecond
		return nil

	case len(beats.Beats) < 2:
		beats.BPM = 0
		beats.Offset = beats.Beats[0].At
		return nil

	default:
		m, c, err := fit(beats.Beats)
		if err != nil {
			return err
		}

		quantized := []Beat{}
		for _, b := range beats.Beats {
			quantized = append(quantized, Beat{
				At:       Seconds(float64(b.beat)*m + c),
				Mean:     b.Mean,
				Variance: b.Variance,
				Taps:     b.Taps,
			})
		}

		beats.BPM, beats.Offset = bpm(quantized)
		beats.Beats = quantized

		return nil
	}
}

// Estimates beats that are not in the provided list by using least squares regression to fit the beats
// to a straight line (assumes the BPM is reasonably constant).
func (beats *Beats) Interpolate(start, end time.Duration) error {
	switch {
	case beats == nil:
		return nil

	case len(beats.Beats) == 0:
		return fmt.Errorf("Insufficient data")

	case len(beats.Beats) == 1 && beats.BPM == 0:
		return fmt.Errorf("Insufficient data")

	case len(beats.Beats) == 1:
		m := 60.0 / float64(beats.BPM)
		c := beats.Beats[0].At.Seconds() - m
		bmin := int(math.Floor((start.Seconds() - c) / m))
		bmax := int(math.Ceil((end.Seconds() - c) / m))

		interpolated := []Beat{}
		for b := bmin; b <= bmax; b++ {
			tt := float64(b)*m + c
			if tt >= start.Seconds() && tt <= end.Seconds() {
				if b == 1 {
					interpolated = append(interpolated, beats.Beats[0])
				} else {
					interpolated = append(interpolated, Beat{At: Seconds(tt)})
				}
			}
		}

		beats.BPM, beats.Offset = bpm(interpolated)
		beats.Beats = interpolated

		return nil

	default:
		m, c, err := fit(beats.Beats)
		if err != nil {
			return err
		}

		index := map[int]Beat{}
		for _, b := range beats.Beats {
			index[b.beat] = b
		}

		bmin := int(math.Floor((start.Seconds() - c) / m))
		bmax := int(math.Ceil((end.Seconds() - c) / m))

		interpolated := []Beat{}
		for b := bmin; b <= bmax; b++ {
			tt := float64(b)*m + c
			if tt >= start.Seconds() && tt <= end.Seconds() {
				if beat, ok := index[b]; ok {
					interpolated = append(interpolated, beat)
				} else {
					interpolated = append(interpolated, Beat{At: Seconds(tt)})
				}
			}
		}

		beats.BPM, beats.Offset = bpm(interpolated)
		beats.Beats = interpolated

		return nil
	}
}

// Reduces the precision of the beats to the specified time value.
func (beats *Beats) Round(precision time.Duration) {
	if beats != nil {
		beats.Offset = beats.Offset.Round(precision)

		for i, b := range beats.Beats {
			beats.Beats[i].At = b.At.Round(precision)
			beats.Beats[i].Mean = b.Mean.Round(precision)
			beats.Beats[i].Variance = b.Variance.Round(precision)
			for j, tap := range b.Taps {
				beats.Beats[i].Taps[j] = tap.Round(precision)
			}
		}
	}
}

// Subtracts a time value from all timeline values in the Beats e.g. to compensate
// for a known latency or to adjust the beats so that the first beat falls on 0.
func (beats *Beats) Sub(dt time.Duration) {
	if beats != nil {
		beats.Offset -= dt
		for i, b := range beats.Beats {
			beats.Beats[i].At = b.At - dt

			if len(b.Taps) > 0 {
				beats.Beats[i].Mean = b.Mean - dt
				for j, t := range b.Taps {
					beats.Beats[i].Taps[j] = t - dt
				}
			}
		}
	}
}

// Custom JSON marshaler for the Beats struct that represents the internal times as (float) seconds.
func (beats Beats) MarshalJSON() ([]byte, error) {
	type beat struct {
		At       instant   `json:"at"`
		Mean     instant   `json:"mean"`
		Variance instant   `json:"variance"`
		Taps     []instant `json:"taps"`
	}

	b := struct {
		BPM    uint    `json:"BPM"`
		Offset instant `json:"offset"`
		Beats  []beat  `json:"beats"`
	}{
		BPM:    beats.BPM,
		Offset: instant(beats.Offset),
		Beats:  make([]beat, len(beats.Beats)),
	}

	for i, bb := range beats.Beats {
		b.Beats[i] = beat{
			At:       instant(bb.At),
			Mean:     instant(bb.Mean),
			Variance: instant(bb.Variance),
			Taps:     make([]instant, len(bb.Taps)),
		}

		for j, t := range bb.Taps {
			b.Beats[i].Taps[j] = instant(t)
		}
	}

	return json.Marshal(b)
}

// Custom JSON unmarshaler for the Beats struct that unmarshals times stored as (float) seconds.
func (beats *Beats) UnmarshalJSON(bytes []byte) error {
	if beats != nil {
		type beat struct {
			At       instant   `json:"at"`
			Mean     instant   `json:"mean"`
			Variance instant   `json:"variance"`
			Taps     []instant `json:"taps"`
		}

		b := struct {
			BPM    uint    `json:"BPM"`
			Offset instant `json:"offset"`
			Beats  []beat  `json:"beats"`
		}{}

		if err := json.Unmarshal(bytes, &b); err != nil {
			return err
		}

		beats.BPM = b.BPM
		beats.Offset = time.Duration(b.Offset)
		beats.Beats = make([]Beat, len(b.Beats))

		for i, bb := range b.Beats {
			beats.Beats[i] = Beat{
				At:       time.Duration(bb.At),
				Mean:     time.Duration(bb.Mean),
				Variance: time.Duration(bb.Variance),
				Taps:     make([]time.Duration, len(bb.Taps)),
			}

			for j, tap := range bb.Taps {
				beats.Beats[i].Taps[j] = time.Duration(tap)
			}
		}
	}

	return nil
}

// Generates the weights array for a set of taps. The returned weights use 1.0 as a base value,
// with the weights of the taps in ieach discounted row being multiplied by (1.0 - forgetting).
func weights(taps [][]time.Duration, forgetting float64) []float64 {
	N := 0
	for _, row := range taps {
		N += len(row)
	}

	array := make([]float64, N)
	switch {
	case forgetting == 0.0:
		for i := range array {
			array[i] = 1.0
		}

	case forgetting > 0.0:
		ix := len(array) - 1
		w := 1.0
		f := 1.0 - forgetting
		for _, row := range taps {
			for range row {
				array[ix] = w
				ix--
			}

			w = w * f
		}

	case forgetting < 0.0:
		ix := 0
		w := 1.0
		f := 1.0 + forgetting
		for _, row := range taps {
			for range row {
				array[ix] = w
				ix++
			}

			w = w * f
		}
	}

	return array
}

// Estimate the BPM and offset of the first beats by applying least squares reqression to a set of beats.
func bpm(beats []Beat) (uint, time.Duration) {
	if len(beats) < 2 {
		return 0, 0
	}

	m, c, err := fit(beats)
	if err != nil {
		return 0, 0
	}

	bpm := uint(math.Round(60.0 / m))

	b0 := int(math.Floor(-c / m))
	t0 := float64(b0)*m + c
	for t0 < 0.0 {
		b0++
		t0 = float64(b0)*m + c
	}

	offset := Seconds(t0)

	return bpm, offset
}

// Performs a least squares reqression on a set of beats and returns the gradient
// and offset of the calculated line.
func fit(beats []Beat) (float64, float64, error) {
	if len(beats) < 2 {
		panic("Insufficient data")
	}

	err := reindex(beats)
	if err != nil {
		return 0, 0, err
	}

	x := []float64{}
	t := []float64{}
	for _, b := range beats {
		x = append(x, float64(b.beat))
		t = append(t, b.At.Seconds())
	}

	m, c := regression.OrdinaryLeastSquares(x, t)

	return m, c, nil
}

// Performs a 'best guess' as to which beat number corresponds to which estimated beat,by fitting the
// beats to a line, adjusting the beats and calculating the variance between the beats and adjusted
// beats. Returns when the average variance is sufficiently low.
func reindex(beats []Beat) error {
	sort.SliceStable(beats, func(i, j int) bool { return beats[i].At < beats[j].At })

	at := make([]float64, len(beats))
	for i, b := range beats {
		at[i] = b.At.Seconds()
	}

	N := len(at)
	index := make([]int, N)

	for i := range index {
		index[i] = i + 1
	}

	// ... trivial cases
	if N <= 2 {
		for i := range beats {
			beats[i].beat = index[i]
		}

		return nil
	}

	// ... 3+ intervals

	x0 := at[0]
	xn := at[N-1]
	y0 := 1.0

	dt := Seconds(xn - x0).Minutes()
	bmax := int(math.Ceil(dt * float64(MaxBPM*MinSubdivision/4)))

loop:
	for i := N; i <= bmax; i++ {
		yn := float64(i)
		m := (yn - y0) / (xn - x0)
		c := yn - m*xn

		x := at[0]
		y := m*x + c
		b0 := math.Round(y)
		index[0] = int(b0)
		sumsq := y*y - 2*y*b0 + b0*b0

		for j := 1; j < N; j++ {
			x := at[j]
			y := m*x + c
			bn := math.Round(y)

			index[j] = int(bn)
			if index[j] <= index[j-1] {
				continue loop
			}

			sumsq += y*y - 2*y*bn + bn*bn
		}

		variance := sumsq / float64(N-1)

		if variance < 0.001 {
			for i := range beats {
				beats[i].beat = index[i]
			}

			return nil
		}
	}

	return fmt.Errorf("Error mapping taps to beats: %v", beats)
}

// Converts a result from the ckmeans.1d.dp algorithm to a Beat.
func makeBeat(at float64, cluster ckmeans.Cluster) Beat {
	taps := make([]time.Duration, len(cluster.Values))

	for i, v := range cluster.Values {
		taps[i] = Seconds(v)
	}

	//	sort.SliceStable(taps, func(i, j int) bool { return taps[i] < taps[j] })

	return Beat{
		At:       Seconds(at),
		Mean:     Seconds(cluster.Center),
		Variance: Seconds(cluster.Variance),
		Taps:     taps,
	}
}
